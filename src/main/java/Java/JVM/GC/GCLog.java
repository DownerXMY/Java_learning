package Java.JVM.GC;

/*
我们通过设定一些JVM的参数,来看到垃圾回收的信息...
-verbose:gc 表示输出详细的垃圾回收的日志
-Xms20M -Xmx20M 表示设定JVM堆空间的大小
-Xmn10M 表示堆空间中新生代的大小,换句话说这三个参数也说明了老年代的大小也是10M
-XX:+PrintGCDetails 表示打印出来垃圾回收的详细信息
-XX:SurvivorRatio=8 表示Eden和Survivor区域的比例
----------------------
我们可以看到有GC和Full GC两种,
其中GC就是表示因为Eden空间满了而导致的Minor GC;
Allocation Failure是最常见的触发垃圾回收的原因,表示内存分配失败;
我们可以看到,JDK8的默认垃圾回收器的搭配还是:吞吐量最优组合;
*/

public class GCLog {

    public static void main(String[] args)
            throws InterruptedException {

        int length = 1024 * 1024;
        // 表示1M的单位

        byte[] MyAlloc1 = new byte[2 * length];
        byte[] MyAlloc2 = new byte[2 * length];
        byte[] MyAlloc3 = new byte[3 * length];
        byte[] MyAlloc4 = new byte[3 * length];

        /*
        之前设置的new是2233,只有Minor GC
        为什么我们改成2222,却出现了Full GC?
        注意我们一定要清楚Full GC触发的时机其实是老年代满了
        我们要详细讲一下这个事情,理解清楚了以后就什么都能想明白了:
        -------------------------
        我们依次罗列一些这个程序在JVM内部发生的事情:
        1.首先我们通过JVM参数-Xms20M,-Xmx20M,-Xmn10M以及-XX:SurvivorRatio=8
          这几个参数说明了Eden空间的大小是8M,新生代和老年代的大小都是10M
        2.如果我们的设定是2233,那么不论如何最后一个对象是不可能在新生代诞生的
        3.我们介绍一条JVM的隐藏规则(担保机制):
            如果一个对象不能在新生代分配足够的内存空间,那么它将直接在老年代诞生
        4.我们用jstat -gc监控,发现新生代执行的垃圾回收的次数是1,
          Full GC执行的次数是1...
        5.实际上,触发Full GC的时机有很多,其实很重要的一块是内存担保机制
        6.那么大概可以这么解释:在2233的时候,其中22会在Eden空间创建,
          然后到33的时候,会直接去老年代创建
          但是在2222的时候,最初四个对象都会创建在新生代,
          然后发现Eden空间满了,执行Minor GC,
          但是这时候我们会发现因为GC进入老年代的内存对象实在是太大了,
          这就会导致触发Full GC
        7.更加专业的解释可以看Page136
         */

        /*
        8.那么还有没有别的办法呢?实际上我们还有一个JVM参数可以介绍
          那就是 -XX:+PrintHeapAtGC
          这个参数可以打印出GC前后堆的可用空间的变化信息
          ------------------------
          这样我们就很容易看到,在2222的情况下:
          首先会有3个字节数组在Eden空间生成,然后就发生了第一次Minor GC
          Eden空间基本被清空了,
          存活下了496k的对象到了第一个Survivor空间中
          存活下了6152K的对象到了老年代
          (当然这里的6152包括了从Survivor空间晋升过来的,也包括了最后一个2M的对象)
          而我们看到的Full GC
          实际上就是将存活在Survivor空间中的496k的对象晋升到了老年代...
          ------------------------
          那么我们可以再看看2233的情况,一样可以很容易分析出全过程
          ------------------------
          最后我们说明这件事情发生的最本质原因:
          什么叫做"由Minor-GC触发的Full-GC"?
          如果说JVM发现老年代剩余的连续空间的大小小于历次新生代晋升到老年代的对象内存的平均
          那么就会触发一次Full-GC,注意这本质上是由内存担保机制引起的,
          我们可以看到这件事情发生在了2222的情况下,但是不存在在2233中...
         */

        System.out.println("Hello world...");

        Thread.sleep(200000);

        System.out.println("Testing is over...");
    }
}

/*
所以我们看了这么多,实际上这是件非常有意义的事情:
首先我们采用了多种监测方式,包括使用工具,添加JVM参数等
最终才艰难地找到了事情背后的解释...
这对于我们了解垃圾收集机制起到了至关重要要的影响
 */
